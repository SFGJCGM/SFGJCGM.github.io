<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Meeting Turn and Next Update at Tue 23:59:59</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      max-width: 500px;
      background-color: #fff;
      padding: 20px;
      margin-top: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
      text-align: center;
    }
    h1 {
      margin-bottom: 10px;
    }
    p {
      margin: 10px 0;
    }
    canvas {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Group Meeting Wheel</h1>
    <canvas id="wheelCanvas" width="400" height="400"></canvas>
    <p id="currentMember"></p>
    <p id="nextUpdateDate"></p>
    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
      The meeting turn updates every Tuesday at 23:59:59 (postponed if itâ€™s a holiday).
    </p>
  </div>

  <script>
    // List of groups (speakers) as members.
    // Each group is a comma-separated list of names.
    const members = [
      "Yuan Shibo, Tommy, Nathan", 
      "Evan, Huang Junkun, Chen Haoxuan",
      "Lyu Weitao, Sun Jialin, Cao Yujie", 
      "Zhuang Zi, Quan Feiyu, Tian Yuxiang"
    ];

    /* 
      Set your reference start date.
      In this example, the reference is Tuesday, February 18, 2025 at 10:00 AM.
      We want the meeting update to be effective on that same day at 23:59:59.
    */
    const startDate = new Date("2025-02-18T10:00:00");

    // Define the number of milliseconds in one week.
    const msPerWeek = 1000 * 60 * 60 * 24 * 7;

    // Helper function:
    // Returns the effective Tuesday update for a given date.
    // The effective Tuesday update is the most recent Tuesday at 23:59:59.
    function getEffectiveTuesdayUpdate(now) {
      let day = now.getDay(); // Sunday = 0, Monday = 1, Tuesday = 2, etc.
      let candidate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      if (day >= 2) {
        // If today is Tuesday or later in the week, candidate date is Tuesday of this week.
        candidate.setDate(now.getDate() - (day - 2));
      } else {
        // If today is Sunday or Monday, candidate is Tuesday of last week.
        candidate.setDate(now.getDate() - (day + 5));
      }
      candidate.setHours(23, 59, 59, 0);
      
      // Special case: if today is Tuesday but before 23:59:59, roll back to previous week's update.
      if (now.getDay() === 2 && now < candidate) {
        candidate.setDate(candidate.getDate() - 7);
      }
      return candidate;
    }

    // Get the current date and time.
    const now = new Date();
    // Compute the effective update time based on the current moment.
    const effectiveUpdateTime = getEffectiveTuesdayUpdate(now);

    // Compute the reference update time based on startDate (set to 23:59:59 on that day).
    const refUpdateTime = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    refUpdateTime.setHours(23, 59, 59, 0);

    // Compute the number of full weeks passed between the reference update time and the effective update time.
    let weekDiff = Math.floor((effectiveUpdateTime - refUpdateTime) / msPerWeek);

    // Calculate the meeting update time (i.e., the pivot Tuesday 23:59:59 for this meeting turn).
    let meetingUpdateTime = new Date(refUpdateTime.getTime() + weekDiff * msPerWeek);

    /* 
      Define an array containing Tuesday dates (in "YYYY-MM-DD" format) representing holidays.
      If a computed meeting update day matches one of these dates, skip to the next week.
    */
    const holidayTuesdays = [
      "2025-02-25", // Tuesday, Feb 25, 2025 (holiday example)
      "2025-03-04"  // Tuesday, Mar 4, 2025 (holiday example)
    ];

    // Check whether the computed meeting update day falls on a holiday.
    while (holidayTuesdays.includes(meetingUpdateTime.toISOString().substring(0, 10))) {
      weekDiff++;
      meetingUpdateTime = new Date(refUpdateTime.getTime() + weekDiff * msPerWeek);
    }

    // Determine the current meeting turn's group.
    const currentIndex = ((weekDiff % members.length) + members.length) % members.length;
    const currentMember = members[currentIndex];

    // Format the meeting update time into a human-readable string (if needed elsewhere).
    const options = { 
      weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    };
    const meetingUpdateTimeString = meetingUpdateTime.toLocaleDateString("en-US", options);

    // Calculate the next update time (i.e. the following Tuesday at 23:59:59).
    let nextUpdateTime = new Date(meetingUpdateTime.getTime() + msPerWeek);
    const nextUpdateTimeString = nextUpdateTime.toLocaleDateString("en-US", options);

    // Update the DOM elements:
    // Here we display only the day (day of the month) from the next update time.
    document.getElementById("currentMember").innerText =
      "This next speakers' turn ( " +nextUpdateTime.getMonth() + nextUpdateTime.getDate() + nextUpdateTime.getFullYear()+"): " + currentMember;
      
    document.getElementById("nextUpdateDate").innerText =
      "Next meeting update is on: " + nextUpdateTimeString;

    // ------------------------------
    // Draw the meeting wheel on the canvas.
    // ------------------------------
    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 20;
    const numSegments = members.length;
    const segmentAngle = 2 * Math.PI / numSegments;
    // Base colors for the segments.
    const colors = ["#FF6384", "#36A2EB", "#FFCE56", "#8BC34A", "#FF9800"];

    // Draw each segment of the wheel.
    for (let i = 0; i < numSegments; i++) {
      const startAngle = i * segmentAngle;
      const endAngle = startAngle + segmentAngle;
      // Calculate the middle angle for this segment.
      const midAngle = startAngle + segmentAngle / 2;
  
      // Create a gradient from the center to the outer edge.
      const innerX = centerX;
      const innerY = centerY;
      const outerX = centerX + radius * Math.cos(midAngle);
      const outerY = centerY + radius * Math.sin(midAngle);
      let gradient = ctx.createLinearGradient(innerX, innerY, outerX, outerY);
      let baseColor = colors[i % colors.length];
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, baseColor);
      
      // Draw the segment.
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();

      // If this segment corresponds to the current meeting turn,
      // highlight it with a red stroke and shadow.
      if (i === currentIndex) {
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.6)";
        ctx.shadowBlur = 10;
        ctx.lineWidth = 8;
        ctx.strokeStyle = "#FF0000";
        ctx.stroke();
        ctx.restore();
      }
      
      // Calculate the position for the text label within the segment.
      const textX = centerX + (radius / 2) * Math.cos(midAngle);
      const textY = centerY + (radius / 2) * Math.sin(midAngle);
      
      // Split the group names by comma and trim any extra whitespace.
      let names = members[i].split(",").map(name => name.trim());
      const lineHeight = 18; // Adjust spacing between lines if needed.
      
      // Center the block of names vertically.
      const totalHeight = names.length * lineHeight;
      const startLineY = textY - totalHeight / 2 + lineHeight / 2;
      
      ctx.fillStyle = "#000000";
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      names.forEach((name, index) => {
        ctx.fillText(name, textX, startLineY + index * lineHeight);
      });
    }
  </script>
</body>
</html>